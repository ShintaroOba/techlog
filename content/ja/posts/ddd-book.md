---
type: Archive
title: 「ドメイン駆動設計入門 -成瀬允宣」を読んだ
date: 2020-12-08
description: 面白かったDDD本のおすすめ
titleWrap: wrap
tags: 
- 本

image: images/summary/ddd.jpg
---


# はじめに

先日、自分の参画しているプロジェクトがドメイン駆動設計を用いたアプリケーション設計をしていたので、勉強がてら読んだ本について粛々とまとめる。
読んだ本は[「ドメイン駆動設計入門 -成瀬允宣」](https://www.amazon.co.jp/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88%E5%85%A5%E9%96%80-%E3%83%9C%E3%83%88%E3%83%A0%E3%82%A2%E3%83%83%E3%83%97%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8B-%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88%E3%81%AE%E5%9F%BA%E6%9C%AC-%E6%88%90%E7%80%AC-%E5%85%81%E5%AE%A3/dp/479815072X/ref=pd_lpo_2?pd_rd_i=479815072X&psc=1)。本書はC#で書かれているが、どの言語でもドメイン駆動設計を落とし込めるような説明になっているため、問題なく読み進めることができた。

ドメイン駆動設計といえば、エリックエヴァンスのドメイン駆動設計  
[Amazon-実践ドメイン駆動設計 (Object Oriented SELECTION)](https://www.amazon.co.jp/%E5%AE%9F%E8%B7%B5%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88-Object-Oriented-SELECTION-%E3%83%B4%E3%82%A1%E3%83%BC%E3%83%B3%E3%83%BB%E3%83%B4%E3%82%A1%E3%83%BC%E3%83%8E%E3%83%B3/dp/479813161X/ref=pd_lpo_1?pd_rd_i=479813161X&psc=1
)
が有名だが、そこまで気合を入れずともドメイン駆動設計のエッセンスがみっちり詰まっているので楽しみながら理解できるはず。


# 用語定義

- ドメイン
    - システム化を対象とする**領域**のこと。ドメインが何かではなくて、ドメインに含まれるものが何か。が重要。
- (ドメイン)モデル
    - 現実の事象、あるいは概念を抽象化した概念。そのため、現実をすべて忠実には再現しない。なにを取捨選択をして再現するかはドメインに依存する。例えばペンからどのような性質を抽出するかはモノを書くというドメインか、値段が安いというドメインかによる。
- 値オブジェクト
    ‐ オブジェクトをプリミティブライクに扱うことができ、副作用の発生しない、リソースに関する操作を持つことのできるオブジェクト。

# 知識を表現するパターン

ドメインの知識をオブジェクトとして表現するには下記のパターンがある。

- ValueObject
- エンティティ
- ドメインサービス

# アプリケーションを表現するパターン

ドメインの知識を表現しただけではドメインの写しがコードとして表現されているだけであり、ソフトウェアとしての要件は満たされない。

ソフトウェアとしての要件を満たすために必要なパターンが下記。

- リポジトリ
- ファクトリ

# 知識を表現するより発展的なパターン

- 集約
- 仕様

## システム固有の値を表現する「ValueObject」

プリミティブな型を使って値の表現をすることがあるが、中でもシステム固有の値を設定したい場合、ValueObjectを定義する。ValueObjectはドメインの何らかの値を計測・定量化・説明したものを表す。

(例：年齢オブジェクト→何年生きてきたか計測し、定量化した値。名前オブジェクト→何と呼ばれているかを説明した値)

ValueObjectに振る舞い(メソッド)を持たせることで、その値に対する処理を限定し、定型化することができる。

言わば、オブジェクトに対する操作を一処にまとめることで、ValueObjectは自身に対するルールを語るドメインオブジェクトらしさを帯びる。

お金であれば加算処理や、消費税算出処理などがあげられる。

ちなみに、値そのものが持つ特性は下記。

- immutable(不変)であること
- 交換が可能であること
- 等価性によって比較されること

ValueObjectはシステム固有の表現であり、値の一種。値が持つ性質はValueObjectにそのまま適用される。

下記に値の性質をValueObjectでどのように表現していくかをまとめる。

### immutableであること

値は不変の性質を持っている。実装時に値の設定はできるが、変更は絶対にタブー。

メリット

- 値が変更されないからこそ安心してオブジェクトのキャッシュができる。
- スレッドセーフ・・・マルチスレッド時、単一オブジェクトに対する更新競合の制御を気にする必要がなくなる

### 交換が可能であること

オブジェクトを生成してしまえば、代入による変更は不可能。

値の変更が必要な場合は変更したい値を設定した新しいインスタンスを生成する。

### 等価性によって比較される

ValueObjectの中身の値を取り出して等価性を比較するのは愚の骨頂。

ValueObjectにequalValueObjectメソッドを持たせ、ValueObject同士で値の比較をすべし。

メリット

- 属性が増えてもValueObject側の修正だけすればよい

**どこまでをValueObjectにする？の判断基準は？**

- 対象の値にルールがあるか　(例：氏名は性と名で構成される)
- その値単体で使用することがあるか　(例：氏名は単体で使われる。性は単体で使われなさそう。→いらない)
    - 特に正規表現や桁数などの制御機能を、氏名オブジェクトに持たせるのか。性、名それぞれに持たせるのか等で考えられる

### **値オブジェクトを使うモチベーション**

- 表現力を増す
    - プリミティブ型では汎用的過ぎて表現力に乏しい。
- 不正な値を存在させない
    - 表現した定義以外の値を代入させない
- 誤った代入を防ぐ
- ロジックの散財を防ぐ
    - DRY(Don't Repeat Yourself)原則によるコードの重複を防ぐ

## エンティティ

エンティティはドメインモデルを実装したドメインオブジェクト。ValueObjectも同じ定義だが、両者の違いは同一性によって識別されるか否か。

ValueObjetはそれが持つ属性によって判断されるが、エンティティの場合、内部の属性が変わっていようとも、属性ではなく、同一性によって識別される。要は属性値が異なっていたとしても、インスタンスのハッシュみたいなもので判断される。

## ドメインサービス

ドメインサービスはドメインモデルのコード上の表現であり、括りとしてはValueObjectやエンティティと同一。そのため、入出力を伴う処理を取り扱わないように注意。

最重視すべきは、ドメインに基づくかそうでないか。(重複チェックとかはドメインに紐づくものではない。)

ValueObjetや円エンティティに記述すると不自然になるふるまいをドメインサービスに記述する。

あくまでValueObjetやエンティティに記述する処理もドメインサービスに書けてしまうので、「不自然なふるまい」のみドメインサービスに書くと決める。

(ドメイン貧血症)を防ぐ。

## リポジトリ

ロジックが特定のインフラストラクチャ技術に依存することはソフトウェアを硬直化することにつながる。

リポジトリを実装することで、データの永続化にまつわる処理を抽象化することができ、ソフトウェアに柔軟性を与える。

例えばより高性能なデータストアが出てきた場合、専用のリポジトリを実装して差し替えればよい。

ドメインのルールに比べると、データストアが何であるかはどうでもよい問題。

## アプリケーションサービス

ドメインサービスと混同しがちだが、明確に分ける。ここでは、ユースケースを実現するオブジェクトと定義する。

ドメインを表現したドメインオブジェクトはそのままではドメインを表現した単体のオブジェクトにすぎないが、アプリケーションサービスの存在によって、ドメインオブジェクトの力を束ね、ユースケースを組み立てることができる。

登録・更新・削除などの各メソッド内で、ドメインのルールはアプリケーションサービスには記述しない。例えば重複確認など。重複確認を各メソッドで書いていくのは筋悪。結果として修正漏れを引き起こす。
あくまでドメインのルールはドメインオブジェクトに書くべきで、アプリケーションサービスはそれを利用することに徹するべき。→ドメインサービスはドメインオブジェクトの操作に徹する。
ルールをドメインオブジェクトに記載することで、同じルールが点在されることを防ぎ、ひいては修正漏れや横展開をなくすことにつながる。

### アプリケーションサービスと凝集度

凝集度とは、モジュールの責任範囲がどれだけ集中しているかを図る尺度。凝集度を高めるとモジュールが一つの事柄に集中していることになり、より良いコードになる。
凝集度が低いコードとは、メンバ変数によって呼び出されるメソッドがあったりなかったりすること。
→こういう場合にクラスを分割してすべてのメソッドですべての変数が呼ばれるようにすることで凝集度を高める。

凝集度はあくまでも一つの指標であって、クラスを構成するインスタンス変数とメソッドには対応関係があり、それが健全であるかを示すヒントである。

### サービスとはなにか

クライアントのために何かを行うモノ。値オブジェクトやエンティティとは異なり、自分自身のための振る舞いを持たず、活動や行動であることが多い。
ドメインサービスはれっきとしたドメインの知識を表現したオブジェクトである。サービスの中では状態を持たせるべきではない。（～フラグがTrue、Falseの場合この処理を行う。みたいなやつ。インスタンスの状態がどういったものかをサービスでいしきしなければならなくなるので、状態をサービスに持たせない。)

## 柔軟性を持たせる依存関係のコントロール

サービスクラスのコンストラクタで、リポジトリクラスなどの下位モジュールのオブジェクトの注入を行う。こうすることで、テスト用のモジュールと本番用のモジュールを差し替えることができるが、リリース時に全モジュールの差し替えを行うのは愚直で面倒な作業。
また、インメモリのリポジトリを参照したい場合などがあるはず。例えばバグの調査などで。
この時にDBにそのエラーのデータを用意して...もしくはそのリポジトリを生成するテストリポジトリへ差し替えして...というのも面倒。
こういった問題を解決するためのパターンとして、ServiceLocator、IoC Containerパターンがある。

### Service Locator

オブジェクトに依存解決先となるオブジェクトを事前に登録しておき、インスタンスが必要となる各所でServiceLocatorを経由してインスタンスを取得する。
差し替えを行う際は、ServiceLocatorで定義したオブジェクトを差し替えればよい。
→Service Locatorにより、サービスクラスから下位モジュールのインスタンス化を行うコードが点在しなくなり、アプリケーションの中核を担うロジックに修正を加えることなく、リポジトリの実態を差し替えられるようになる。

**デメリット**

- 依存関係が外部から見えなくなる
    - サービスクラスのコンストラクタはServiceLocatorのみになるので変数がかかれないため。
- テストの維持が難しくなる

- IoC Container(DI Container)

## 生成処理を行うファクトリ

複雑なオブジェクトはその生成処理も複雑になることがある。

生成処理自体がドメインにおいて意味を持たないにしても、ドメインを表現する層の責務であることには変わらない。

求められることは、複雑なオブジェクトの生成処理をオブジェクトとして定義すること。このオブジェクトのことをファクトリという。

本来であれば初期化はコンストラクタの役目であるが、コンストラクタは単純であるべき。

コンストラクタが単純でないときにファクトリを作ってよい。コンストラクタ内で

エンティティ内の属性値を用いてあるエンティティをnewするときとかはそのエンティティにファクトリメソッド作ってよい。例えばユーザが料理オブジェクトを生成する場合、UserにFactoryを用意する。